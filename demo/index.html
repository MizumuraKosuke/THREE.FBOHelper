<!doctype html>
<html lang="en">
	<head>
		<title>Demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			*{
				box-sizing: border-box;
				font-family: 'Roboto Slab', sans-serif;
				font-size: 13px;
				font-weight: 100;
				margin :0;
				padding: 0;
			}
			html {
				height: 100%;
			}
			body {
				margin: 0;
				padding: 0;
				background-color: #000000;
				color: #ffffff;
				line-height: 20px;
				height: 100%;
				overflow: hidden;
				font-family: 'Roboto Slab', sans-serif;
				font-size: 13px;
				font-weight: 100;
			}
			#container {
				position: absolute;
				left: 0;
				top: 0;
				right: 0;
				bottom: 0;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>

		<script src="js/three.js"></script>
		<script src="../src/THREE.FBOHelper.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/Maf.js"></script>


<script id="ortho-vs" type="x-shader/x-vertex" >
precision highp float;

attribute vec3 position;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec2 vUv;

void main() {

	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );

}
</script>

<script id="velocity-fs" type="x-shader/x-fragment" >
precision highp float;

uniform sampler2D inputTexture;
uniform sampler2D positionTexture;
uniform sampler2D originalTexture;

uniform float time;

uniform vec4 sphere[ 20 ];
uniform vec4 sphereVelocities[ 20 ];
uniform mat4 sphereRotationMatrix;

varying vec2 vUv;

float sdTorus( vec3 p, vec2 t ) {
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

float sdSphere( vec3 p, float s ) {
	return length(p)-s;
}

void main() {

	vec4 c = texture2D( inputTexture, vUv );
	vec4 p = texture2D( positionTexture, vUv );
	if( p.a == 0. ) {
		vec4 o = texture2D( originalTexture, vUv );
		c.xyz = 100. * normalize( o.xyz );
		c.y = 0.;
	}

	if( ( p.y + c.y ) < -500. ) c.y *= -.75;
	if( p.y + 500. < .1 ) c.y *= .5;

	for( int j = 0; j < 20; j++ ) {
		float r = sphere[ j ].a;
		vec3 pp = ( sphereRotationMatrix * vec4( sphere[ j ].xyz, 0. ) ).xyz - ( p.xyz + c.xyz );
		float d = ( r * r ) / ( pp.x * pp.x + pp.y * pp.y + pp.z * pp.z ) ;
		if( d >= 1.0 ) {
			vec3 n = normalize( pp.xyz );
			vec3 i = normalize( c.xyz );
			float f = .25 * length( c.xyz );
			c.xyz = f * reflect( i, n );
			c.xyz += sphereVelocities[ j ].xyz;
		}
	}

	c.y -= .098;
	//c *= .99;

	gl_FragColor = c;

}
</script>

<script id="position-fs" type="x-shader/x-fragment" >
precision highp float;

uniform sampler2D originalTexture;
uniform sampler2D infoTexture;
uniform sampler2D inputTexture;
uniform sampler2D velocityTexture;

varying vec2 vUv;

void main() {

	vec4 c = texture2D( inputTexture, vUv );
	vec4 i = texture2D( infoTexture, vUv );
	vec4 or = texture2D( originalTexture, vUv );
	if( c.a == 0. ) {
		c = or;
	}

	vec4 v = texture2D( velocityTexture, vUv );
	c.xyz += i.x * v.xyz;
	c.a += i.x;
	if( c.a > 1000. ) c.a = 0.;

	gl_FragColor = vec4( c );

}

</script>

<script id="particle-vs" type="x-shader/x-vertex">
precision highp float;

attribute vec3 position;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

uniform vec2 dimensions;
uniform float size;
uniform vec3 cameraPosition;

uniform sampler2D infoTexture;
uniform sampler2D originalTexture;
uniform sampler2D positionTexture;
uniform sampler2D previousPositionTexture;

uniform vec3 colors[ 9 ];

varying float vSize;
varying vec2 vUv;
varying vec3 vColor;
varying float life;

void main() {

	vec4 i = texture2D( infoTexture, uv );
	vec4 c = texture2D( positionTexture, uv );
	vec4 prev = texture2D( previousPositionTexture, uv );
	vec3 p = c.xyz;
	vUv = uv;
	life = 1. - ( c.a / 1000. );
	if( c.a == 0. ) life = 0.;
	vColor = mix( vec3( 149., 200., 233. ) / 255., vec3( 24., 113., 169. ) / 255., life );
	vColor = mix( vec3( 1. ), vColor, clamp( .1 * length( c - prev ), 0., 1. ) );

    float cameraDist = length( p - cameraPosition );
	vSize = clamp( i.x * 5000. / cameraDist, 2., 100. );//( 100. - c. a ) * 500. / cameraDist;
	gl_PointSize = vSize;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1. );

}

</script>

<script id="particle-fs" type="x-shader/x-vertex">
precision highp float;

varying float vSize;
varying vec2 vUv;
varying vec3 vColor;
varying float life;

void main() {

	if( vSize == 0. ) discard;
	float d = smoothstep( .5, .55, 1. - length( gl_PointCoord - .5 ) );
	if( d == 0. ) discard;
	gl_FragColor = vec4( vColor, d * life );

}

</script>

<script>

'use strict';

var camera, controls, geometry,
	scene, material,
	particleGeometry, particleMaterial, particleSystem,
	renderer,
	container,
	mesh, helper,
	sphere;
var positionSim, velocitySim;
var spheres = [], sphereMesh = [], sphereObject = new THREE.Object3D();
var floor;

var container = document.getElementById( 'container' );

window.addEventListener( 'load', init );

function createFBO( width, height ) {

	var fbo = new THREE.WebGLRenderTarget( width, height, {
		wrapS: THREE.ClampToEdgeWrapping,
		wrapT: THREE.ClampToEdgeWrapping,
		minFilter: THREE.NearestFilter,
		magFilter: THREE.NearestFilter,
		format: THREE.RGBAFormat,
		type: THREE.FloatType,
		stencilBuffer: false,
		depthBuffer: false
	});

	fbo.texture.generateMipmaps = false;

	return fbo;

}

var size = window.location.hash.substr( 1 ) || 256;
var width = size;
var height = size;

function GPUSim( renderer, width, height, shader ) {

	this.renderer = renderer;
	this.shader = shader;
	this.orthoScene = new THREE.Scene();
	var fbo = createFBO( width, height );
	this.fbos = [ fbo, fbo.clone() ];
	this.current = 0;
	this.output = this.fbos[ 0 ];
	this.orthoCamera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, .00001, 1000 );
	this.orthoQuad = new THREE.Mesh( new THREE.PlaneBufferGeometry( width, height ), this.shader );
	this.orthoScene.add( this.orthoQuad );

}

GPUSim.prototype.render = function() {

	this.shader.uniforms.inputTexture.value = this.fbos[ this.current ];
	this.input = this.fbos[ this.current ];
	this.current = 1 - this.current;
	this.output = this.fbos[ this.current ];
	this.renderer.render( this.orthoScene, this.orthoCamera, this.output );

}

function init() {

	container = document.getElementById( 'container' );

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
	camera.target = new THREE.Vector3( 0, 0, 0 );
	camera.position.z = 1000;
	camera.position.y = 1000;
	scene.add( camera );

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.sortObjects = false;

	helper = new THREE.FBOHelper( renderer );

	container.appendChild( renderer.domElement );

	window.addEventListener( 'resize', onWindowResized );
	onWindowResized();

	var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
	scene.add( light );

	var material = new THREE.MeshStandardMaterial( { roughness: .5, metalness: .2 } );

	floor = new THREE.Mesh( new THREE.BoxBufferGeometry( 2000, 2000, 10 ), material );
	floor.position.y = -505;
	floor.rotation.x = Math.PI / 2;
	//scene.add( floor );

	controls = new THREE.OrbitControls( camera, renderer.domElement );

	var ptr = 0;
	var data = new Float32Array( width * height * 4 );
	var data2 = new Float32Array( width * height * 4 );

	for( var y = 0; y < height; y++ ) {
		for( var x = 0; x < width; x++ ) {

			var px = Maf.randomInRange( -40, 40 );
			var pz = Maf.randomInRange( -40, 40 );


			data[ ptr ] = px
			data[ ptr + 1 ] = Maf.randomInRange( 1400, 1500 );
			data[ ptr + 2 ] = pz;
			data[ ptr + 3 ] = Maf.randomInRange( 1, 499 );

			data2[ ptr ] = Maf.randomInRange( 1, 2 );

			ptr += 4;
		}
	}
	var texture = new THREE.DataTexture( data, width, height, THREE.RGBAFormat, THREE.FloatType );
	texture.minFilter = THREE.NearestFilter;
	texture.magFilter = THREE.NearestFilter;
	texture.needsUpdate = true;

	var texture2 = new THREE.DataTexture( data2, width, height, THREE.RGBAFormat, THREE.FloatType );
	texture2.minFilter = THREE.NearestFilter;
	texture2.magFilter = THREE.NearestFilter;
	texture2.needsUpdate = true;

	var uniformSpheres = [];
	var uniformSpheresVelocities = [];
	for( var j = 0; j < 20; j++ ) {
		var r = Maf.randomInRange( 100, 200 );
		var x = Maf.randomInRange( -400, 400 );
		var y = Maf.randomInRange( -400, 400 );
		var z = Maf.randomInRange( -400, 400 );

		spheres.push( new THREE.Vector4( x, y, z, r ) );
		uniformSpheres.push( new THREE.Vector4( 0, 0, 0, 0 ) );
		uniformSpheresVelocities.push( new THREE.Vector4( 0, 0, 0, 0 ) );
		var s = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 3 ), material );
		s.scale.set( r, r, r );
		sphereObject.add( s );
		sphereMesh.push( s );
	}
	//scene.add( sphereObject );

	var velocityShader = new THREE.RawShaderMaterial( {
		uniforms:{
			time: { type: 'f', value: 0 },
			originalTexture: { type: 't', value: texture },
			positionTexture: { type: 't', value: texture },
			inputTexture: { type: 't', value: null },
			sphere: { type: 'v4v', value: uniformSpheres },
			sphereVelocities: { type: 'v4v', value: uniformSpheresVelocities },
			sphereRotationMatrix: { type: 'm4', value: new THREE.Matrix4() }
		},
		vertexShader: document.getElementById( 'ortho-vs' ).textContent,
		fragmentShader: document.getElementById( 'velocity-fs' ).textContent,
		depthTest: false,
		depthWrite: false
	} );

	velocitySim = new GPUSim( renderer, width, height, velocityShader );

	helper.attach( velocitySim.fbos[ 0 ], 'Velocity FBO#0' );
	helper.attach( velocitySim.fbos[ 1 ], 'Velocity FBO#1' );

	var positionShader = new THREE.RawShaderMaterial( {
		uniforms:{
			originalTexture: { type: 't', value: texture },
			infoTexture: { type: 't', value: texture2 },
			inputTexture: { type: 't', value: null },
			velocityTexture: { type: 't', value: null }
		},
		vertexShader: document.getElementById( 'ortho-vs' ).textContent,
		fragmentShader: document.getElementById( 'position-fs' ).textContent,
		depthTest: false,
		depthWrite: false
	} );

	positionSim = new GPUSim( renderer, width, height, positionShader );

	helper.attach( positionSim.fbos[ 0 ], 'Position FBO#0' );
	helper.attach( positionSim.fbos[ 1 ], 'Position FBO#1' );

	particleGeometry = new THREE.BufferGeometry();

	var dimensions = new THREE.Vector2( width, height );
	var particles = width * height;
	var positions = new Float32Array( particles * 3 );
	var uvs = new Float32Array( particles * 2 );

	for ( var i = 0, i3 = 0, i2 = 0; i < particles; i ++, i3 += 3, i2 += 2 ) {

		positions[ i3 + 0 ] = Maf.randomInRange( 1, 2 );
		positions[ i3 + 1 ] = Maf.randomInRange( -100, 100 );
		positions[ i3 + 2 ] = Maf.randomInRange( -100, 100 );

		var x = ( i % dimensions.x ) / dimensions.x;
		var y = Math.floor( i / dimensions.x ) % dimensions.y / dimensions.y;
		uvs[ i2 + 0 ] = x;
		uvs[ i2 + 1 ] = y;

	}

	particleGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	particleGeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	particleMaterial = new THREE.RawShaderMaterial( {
		uniforms:{
			originalTexture: { type: 't', value: texture },
			infoTexture: { type: 't', value: texture2 },
			positionTexture: { type: 't', value: positionSim.fbos[ 0 ] },
			previousPositionTexture: { type: 't', value: positionSim.fbos[ 1 ] },
			dimensions: { type: 'v2', value: dimensions },
			cameraPosition: { type: 'v3', value: new THREE.Vector3() }
		},
		vertexShader: document.getElementById( 'particle-vs' ).textContent,
		fragmentShader: document.getElementById( 'particle-fs' ).textContent,
		transparent: true,
		depthWrite: false
	} );

	particleSystem = new THREE.Points( particleGeometry, particleMaterial );

	scene.add( particleSystem );

	animate();

}

function onWindowResized( event ) {

	renderer.setSize( container.clientWidth, container.clientHeight );
	camera.aspect = container.clientWidth / container.clientHeight;
	camera.updateProjectionMatrix();

	helper.setSize(  container.clientWidth, container.clientHeight );

}

function animate() {

	controls.update();

	requestAnimationFrame( animate );
	render();

}

var tmpVector = new THREE.Vector3();
var runAnimation = true;

window.addEventListener( 'keydown', function(e ) {
	if( e.keyCode === 32 ) runAnimation = !runAnimation;
} );

var time = 0;
var lastTime = 0;
var tmpVector = new THREE.Vector4();

function render() {

	if( runAnimation ) {

		time += .001 * ( performance.now() - lastTime );

		spheres.forEach( function( s, i ) {

			var r = 400;
			tmpVector.copy( velocitySim.shader.uniforms.sphere.value[ i ] );
			velocitySim.shader.uniforms.sphere.value[ i ].set(
				s.x + r * Math.cos( time ),
				s.y,
				s.z + r * Math.sin( time ),
				s.w
			);

			velocitySim.shader.uniforms.sphereVelocities.value[ i ].copy( velocitySim.shader.uniforms.sphere.value[ i ] );
			velocitySim.shader.uniforms.sphereVelocities.value[ i ].sub( tmpVector );

			sphereMesh[ i ].position.set(
				velocitySim.shader.uniforms.sphere.value[ i ].x,
				velocitySim.shader.uniforms.sphere.value[ i ].y,
				velocitySim.shader.uniforms.sphere.value[ i ].z
			);

		} )

		velocitySim.shader.uniforms.time.value = time;
		sphereObject.rotation.z = time;
		velocitySim.shader.uniforms.sphereRotationMatrix.value.makeRotationZ( time );
		velocitySim.render();
		positionSim.shader.uniforms.velocityTexture.value = velocitySim.output;
		positionSim.render();
		particleMaterial.uniforms.positionTexture.value = positionSim.output;
		particleMaterial.uniforms.previousPositionTexture.value = positionSim.input;
		velocitySim.shader.uniforms.positionTexture.value = positionSim.output;

	}

	particleMaterial.uniforms.cameraPosition.value.copy( camera.position );
	renderer.render( scene, camera );
	helper.update();

	lastTime = performance.now();

}

</script>

	</body>
</html>
